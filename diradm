#!/bin/bash
#
################################################################################
#
# diradm:	A tool for managing posix users and groups in a LDAP directory.
#		It uses ldap[add|modify|delete] from the OpenLDAP project.
#
# Version:	$Header: /code/convert/cvsroot/infrastructure/diradm/Attic/diradm,v 1.13 2003/07/29 23:43:07 robbat2 Exp $
#
# Copyright (C) 2003  Daniel Himler  <dan@hits.at>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
################################################################################

CONFIG_FILENAME="diradm.conf"
CONFIG="/etc/${CONFIG_FILENAME}"
[ ! -f "${CONFIG}" ] && CONFIG="`dirname ${0}`/${CONFIG_FILENAME}"
[ ! -f "${CONFIG}" ] && CONFIG="~/.${CONFIG_FILENAME}"

##################### Don't touch anything below this line #####################

VERSION="1.1"

if [ ! -r "${CONFIG}" ]; then
	echo "Unable to open configuration file \"${CONFIG}\"!"
	exit 1
fi

DEPENDENCIES="grep ldapsearch ldapadd ldapmodify ldapdelete sed stat"
for DEPENDENCY in ${DEPENDENCIES}; do
	EXECUTABLE="$(which "${DEPENDENCY}" 2> /dev/null)"
	if [ ! -x "${EXECUTABLE}" ]; then
		echo "Cannot find \"${DEPENDENCY}\"!"
		exit 1
	fi
done

source "${CONFIG}"
CONFIGOPTIONS_STRING="LDAPURI BINDDN USERBASE GROUPBASE HOMEBASE SKEL
	DEFAULT_LOGINSHELL"
CONFIGOPTIONS_DIGIT="UIDNUMBERMIN UIDNUMBERMAX HOMEPERM DEFAULT_GIDNUMBER
	GIDNUMBERMIN GIDNUMBERMAX SHADOWMIN SHADOWMAX SHADOWWARNING"
CONFIGOPTIONS_DIGIT_DISABLE="DEFAULT_SHADOWINACTIVE SHADOWFLAG"
CONFIGOPTIONS_DATE_DISABLE="DEFAULT_SHADOWEXPIRE"
for CONFIGOPTION in ${CONFIGOPTIONS_STRING}; do
	eval VALUE="\$${CONFIGOPTION}"
	if [ -z "${VALUE}" ]; then
		echo "Configuration error: ${CONFIGOPTION} not defined!"
		exit 1
	fi
done
for CONFIGOPTION in ${CONFIGOPTIONS_DIGIT}; do
	eval VALUE="\$${CONFIGOPTION}"
	if [ -z "${VALUE}" ]; then
		echo "Configuration error: ${CONFIGOPTION} not defined!"
		exit 1
	else
		echo "${VALUE}" | grep -qs "^[[:digit:]]*$"
		if [ "$?" -ne 0 ]; then
			echo "Configuration error: ${CONFIGOPTION} has invalid numerical value \"${VALUE}\"!"
			exit 1
		fi
	fi
done
for CONFIGOPTION in ${CONFIGOPTIONS_DIGIT_DISABLE}; do
	eval VALUE="\$${CONFIGOPTION}"
	if [ -z "${VALUE}" ]; then
		echo "Configuration error: ${CONFIGOPTION} not defined!"
		exit 1
	else
		if [ "${VALUE}" != "-1" ]; then
			echo "${VALUE}" | grep -qs "^[[:digit:]]*$"
			if [ "$?" -ne 0 ]; then
				echo "Configuration error: ${CONFIGOPTION} has invalid numerical value \"${VALUE}\"!"
				exit 1
			fi
		fi
	fi
done
for CONFIGOPTION in ${CONFIGOPTIONS_DATE_DISABLE}; do
	eval VALUE="\$${CONFIGOPTION}"
	if [ -z "${VALUE}" ]; then
		echo "Configuration error: ${CONFIGOPTION} not defined!"
		exit 1
	else
		if [ "${VALUE}" != "-1" ]; then
			echo "${VALUE}" | grep -qs "^[[:digit:]]\{4\}-[[:digit:]]\{2\}-[[:digit:]]\{2\}$"
			if [ "$?" -ne 0 ]; then
				echo "Configuration error: ${CONFIGOPTION} has invalid date value \"${VALUE}\"!"
				exit 1
			fi
		fi
	fi
done

OPTIONS="-x -H ${LDAPURI}"
if [ -n "${BINDPASS}" ]; then
	ADMINOPTIONS="${OPTIONS} -D ${BINDDN} -w ${BINDPASS}"
else
	ADMINOPTIONS="${OPTIONS} -D ${BINDDN} -W"
fi
LDAPSEARCH="ldapsearch ${ADMINOPTIONS}"
LDAPADD="ldapadd ${ADMINOPTIONS}"
LDAPMODIFY="ldapmodify ${ADMINOPTIONS}"
LDAPDELETE="ldapdelete ${ADMINOPTIONS}"

print_usage () {
	echo "Usage: diradm useradd [-u uid [-o]] [-g group] [-G group,...] [-h hosts]"
	echo "                      [-d home] [-s shell] [-c comment] [-m [-k template]]"
	echo "                      [-f inactive] [-e expire] [-p passwd] name"
	echo
	echo "       diradm usermod [-u uid [-o]] [-g group] [-G group,...] [-h hosts]"
	echo "                      [-d home [-m]] [-s shell] [-c comment] [-l new_name]"
	echo "                      [-f inactive] [-e expire ] [-p passwd] [-L|-U] name"
	echo
	echo "       diradm userdel [-r] name"
	echo
	echo "       diradm groupadd [-g gid [-o]] group"
	echo
	echo "       diradm groupmod [-g gid [-o]] [-n name] group"
	echo
	echo "       diradm groupdel group"
	echo
	echo "       diradm chsh [-s login_shell] name"
	echo
    echo "       diradm chfn [-f full_name] [-r room_no] [-w work_ph] [-h home_ph]" 
	echo "                   [-o other] name"
	echo
	echo "       diradm chage [-m mindays] [-M maxdays] [-d lastday] [-I inactive]"
	echo "	                  [-E expiredate] [-W warndays] user"
	echo "       diradm chage -l user"
	echo
	echo "       diradm gpasswd group"
	echo "       diradm gpasswd -a user group"
	echo "       diradm gpasswd -d user group"
	echo "       diradm gpasswd -R group"
	echo "       diradm gpasswd -r group"
	echo "       diradm gpasswd [-A user,...] [-M user,...] group"
	echo
	echo "       diradm --version   Print diradm version number, then exit"
	echo
	echo "       diradm --help      Print this help, then exit"
}

print_version () {
	echo "diradm ${VERSION}"
	echo "Copyright (C) 2003 Daniel Himler <dan@hits.at>"
	echo "This is free software; see the source for copying conditions.  There is NO"
	echo "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
}

# eg: 
# ldap_search_getattr "${GROUPBASE}" "gidNumber=100" cn
# (returns 'users' on systems with that initial data in LDAP)
ldap_search_getattr() {
	basedn="${1}"
	search="${2}"
	attr="${3}"
	regex="^${attr}:{1,2} "
	${LDAPSEARCH} -b "${basedn}" "${search}" ${attr} | egrep "${regex}" | sed -re "s/${regex}//"
}

search_user() {
	${LDAPSEARCH} -b "${USERBASE}" "${1}=${2}" | grep -qs "^${1}: ${2}$"
	return "$?"
}

search_group() {
	${LDAPSEARCH} -b "${GROUPBASE}" "${1}=${2}" | grep -qs "^${1}: ${2}$"
	return "$?"
}

append() {
[ "x${*}" != "x" ] && COMMAND="${COMMAND}\n${*}"
}

append_attribute() {
	local attrib="$1"
	shift
	append "replace: ${attrib}\n${attrib}: ${*}"
}

runmodify() {
[ -n "${COMMAND}" ] && echo -e "${COMMAND}" | ${LDAPMODIFY} > /dev/null
}

runadd() {
[ -n "${COMMAND}" ] && echo -e "${COMMAND}" | ${LDAPADD} > /dev/null
}

rundelete() {
[ -n "${*}" ] && ${LDAPDELETE} "${*}" > /dev/null
}

samba_getdomainsid() {
	net getlocalsid ${SAMBA_DOMAIN} 2>/dev/null |tail -n1 |cut -d: -f2- |xargs
}
samba_nextrid() {
}

Save some animals, eat a vegetarian

# Convert N days since Jan 1, 1970 to a date
# first paramater is the days
# rest is passed to date
days_to_date() {
local D="${1}"
shift
[ -n "$*" ] && local OPT="+'${*}'"
date -u -d "Jan $((${D}+1)), 1970" ${OPT}
}

# Does the reverse of days_to_date
# expects a date
# returns a number of days since Jan 1, 1970
date_to_days() {
local UNIXTIMESTAMP="$(date -u +%s -d "${*}")"
echo $((${UNIXTIMESTAMP}/(3600*24)))
}

daysnow() {
	date_to_days `date -u`
}


useradd () {
	[ -z "${modulename}" ] && modulename="useradd"
	while getopts "u:og:G:h:d:s:c:mk:f:e:p:" OPTION; do
		case "${OPTION}" in
			u) UIDNUMBER="${OPTARG}";;
			o) DUPLICATES="yes";;
			g) GID="${OPTARG}";;
			G) OTHERGROUPS="${OPTARG}";;
			h) HOSTLIST="${OPTARG}";;
			d) HOMEDIRECTORY="${OPTARG}";;
			s) LOGINSHELL="${OPTARG}";;
			c) COMMENT="${OPTARG}";;
			m) CREATEHOMEDIR="yes";;
			k) SKEL="${OPTARG}";;
			f) SHADOWINACTIVE="${OPTARG}";;
			e) SHADOWEXPIRE="${OPTARG}";;
			p) USERPASSWORD="${OPTARG}";;
			*) exit 1;;
		esac
	done
	shift $((${OPTIND} - 1))
	if [ "${#}" -ne 1 ]; then
		print_usage
		exit 2
	else
		LOGIN="${1}"
	fi
	echo "${LOGIN}" | grep -qs "^[[:alnum:]]*$"
	if [ "$?" -ne 0 ]; then
		echo "${modulename}: Invalid user name \"${LOGIN}\""
		exit 3
	else
		search_user "uid" "${LOGIN}"
		if [ "$?" -eq 0 ]; then
			echo "${modulename}: User \"${LOGIN}\" exists"
			exit 9
		fi
	fi
	if [ -n "${UIDNUMBER}" ]; then
		echo "${UIDNUMBER}" | grep -qs "^[[:digit:]]*$"
		if [ "$?" -ne 0 ]; then
			echo "${modulename}: Invalid numeric argument \"${UIDNUMBER}\""
			exit 3
		fi
		search_user "uidNumber" "${UIDNUMBER}"
		if [ "$?" -eq 0 -a "${DUPLICATES}" != "yes" ]; then
			echo "${modulename}: uid ${UIDNUMBER} is not unique"
			exit 4
		fi
	else
		UIDNUMBER="${UIDNUMBERMIN}"
		while [ "${UIDNUMBER}" -le "${UIDNUMBERMAX}" ]; do
			search_user "uidNumber" "${UIDNUMBER}"
			[ "$?" -ne 0 ] && break
			let UIDNUMBER="${UIDNUMBER} + 1"
		done
	fi
	if [ -n "${GID}" ]; then
		echo "${GID}" | grep -qs "^[[:digit:]]*$"
		if [ "$?" -eq 0 ]; then
			GIDNUMBER="${GID}"
		else
			GIDNUMBER="$(ldap_search_getattr "${GROUPBASE}" "cn=${GID}" gidNumber)"
			if [ -z "${GIDNUMBER}" ]; then
				echo "${modulename}: Unknown group \"${GID}\""
				exit 6
			fi
		fi
	else
		GIDNUMBER="${DEFAULT_GIDNUMBER}"
	fi
	search_group "gidNumber" "${GIDNUMBER}"
	if [ "$?" -ne 0 ]; then
		echo "${modulename}: Warning! Group ${GIDNUMBER} not found. Adding user anyway."
	fi
	if [ -n "${OTHERGROUPS}" ]; then
		OTHERGROUPS="${OTHERGROUPS//,/ }"
		for POSIXGROUP in ${OTHERGROUPS}; do
			echo "${POSIXGROUP}" | grep -qs "^[[:digit:]]*$"
			if [ "$?" -eq 0 ]; then
				search_group "gidNumber" "${POSIXGROUP}"
				if [ "$?" -ne 0 ]; then
					echo "${modulename}: Unknown group \"${POSIXGROUP}\""
					exit 6
				fi
				POSIXGROUP="$(ldap_search_getattr "${GROUPBASE}" "gidNumber=${POSIXGROUP}" cn)"
				ADDTOGROUPS="${ADDTOGROUPS} ${POSIXGROUP}"
			else
				search_group "cn" "${POSIXGROUP}"
				if [ "$?" -ne 0 ]; then
					echo "${modulename}: Unknown group \"${POSIXGROUP}\""
					exit 6
				fi
				ADDTOGROUPS="${ADDTOGROUPS} ${POSIXGROUP}"
			fi
		done
	fi
	if [ -n "${HOSTLIST}" ]; then
		HOSTLIST="${HOSTLIST//,/ }"
		for HOST in ${HOSTLIST}; do
			HOSTS="${HOSTS}host: ${HOST}\n"
		done
		HOSTS="$(echo -e "${HOSTS}")"
	fi
	[ -z "${HOMEDIRECTORY}" ] && HOMEDIRECTORY="${HOMEBASE}/${LOGIN}"
	echo "${HOMEDIRECTORY}" | grep -qs "^/"
	if [ "$?" -ne 0 ]; then
		echo "${modulename}: Invalid home directory \"${HOMEDIRECTORY}\""
		exit 3
	fi
	[ -z "${LOGINSHELL}" ] && LOGINSHELL="${DEFAULT_LOGINSHELL}"
	echo "${LOGINSHELL}" | grep -qs "^/"
	if [ "$?" -ne 0 ]; then
		echo "${modulename}: Invalid shell \"${LOGINSHELL}\""
		exit 3
	fi
	[ -z "${COMMENT}" ] && COMMENT="${LOGIN},,,"
	if [ -n "${HOMEDIRECTORY}" -a "${CREATEHOMEDIR}" = "yes" ]; then
		if [ "$(whoami)" != "root" ]; then
			echo "${modulename}: Only root may create home directories"
			exit 12
		fi
		PARENTDIR="$(dirname "${HOMEDIRECTORY}")"
		if [ ! -w "${PARENTDIR}" ]; then
			echo "${modulename}: Cannot create directory \"${HOMEDIRECTORY}\""
			exit 12
		fi
	fi
	[ -z "${SHADOWINACTIVE}" ] && SHADOWINACTIVE="${DEFAULT_SHADOWINACTIVE}"
	if [ "${SHADOWINACTIVE}" != "-1" ]; then
		echo "${SHADOWINACTIVE}" | grep -qs "^[[:digit:]]*$"
		if [ "$?" -ne 0 ]; then
			echo "${modulename}: Invalid numeric argument \"${SHADOWINACTIVE}\""
			exit 3
		fi
	fi
	[ -z "${SHADOWEXPIRE}" ] && SHADOWEXPIRE="${DEFAULT_SHADOWEXPIRE}"
	if [ "${SHADOWEXPIRE}" != "-1" ]; then
		echo "${SHADOWEXPIRE}" | grep -qs "^[[:digit:]]\{4\}-[[:digit:]]\{2\}-[[:digit:]]\{2\}$"
		if [ "$?" -ne 0 ]; then
			echo "${modulename}: Invalid date \"${SHADOWEXPIRE}\""
			exit 3
		else
			SHADOWEXPIRE="$(date_to_days "${SHADOWEXPIRE}")"
		fi
	fi
	# Set this to today's date
	# This is N days since Jan 1, 1970
	SHADOWLASTCHANGE="$(daysnow)"

	# Users Full Name
	FULLNAME="$(echo ${COMMENT} | cut -d, -f1)"
	ROOMNUMBER="$(echo ${COMMENT} | cut -d, -f2)"
	WORKPHONE="$(echo ${COMMENT} | cut -d, -f3)"
	HOMEPHONE="$(echo ${COMMENT} | cut -d, -f4)"
	FIRSTNAME="${FULLNAME// *}"
	SURNAME="${FULLNAME##* }"
	CN="${FIRSTNAME}"

	# Setup the commands
	append "dn: uid=${LOGIN},${USERBASE}"
	append "changetype: add"
	append "objectClass: top"
	append "objectClass: account"
	append "objectClass: posixAccount"
	append "objectClass: shadowAccount"
	append "objectClass: organizationalPerson"
	append "objectClass: inetOrgperson"
	append "uid: ${LOGIN}"
	append "userPassword: ${USERPASSWORD}"
	append "uidNumber: ${UIDNUMBER}"
	append "gidNumber: ${GIDNUMBER}"
	append "cn: ${CN}"
	append "homeDirectory: ${HOMEDIRECTORY}"
	append "loginShell: ${LOGINSHELL}"
	append "shadowLastChange: ${SHADOWLASTCHANGE}"
	append "shadowInactive: ${SHADOWINACTIVE}"
	append "shadowExpire: ${SHADOWEXPIRE}"
	append "shadowMin: ${SHADOWMIN}"
	append "shadowMax: ${SHADOWMAX}"
	append "shadowWarning: ${SHADOWWARNING}"
	append "shadowFlag: ${SHADOWFLAG}"
	[ -n "${HOSTS}" ] && append "${HOSTS}"
	[ -n "${SURNAME}" ] && append "sn: ${SURNAME}"
	[ -n "${FIRSTNAME}" ] && append "givenName: ${FIRSTNAME}"
	[ -n "${FULLNAME}" ] && append "displayName: ${FULLNAME}"
	[ -n "${ROOMNUMBER}" ] && append "roomNumber: ${ROOMNUMBER}"
	[ -n "${HOMEPHONE}" ] && append "homePhone: ${HOMEPHONE}"
	[ -n "${WORKPHONE}" ] && append "telephoneNumber: ${WORKPHONE}"
	append "gecos: ${COMMENT}"
	append "\n\n"

	if [ -n "${ADDTOGROUPS}" ]; then
		DELETEFROMGROUPS="$(ldap_search_getattr "${GROUPBASE}" "memberUid=${LOGIN}" cn)"
		for POSIXGROUP in ${DELETEFROMGROUPS}; do
			append "dn: cn=${POSIXGROUP},${GROUPBASE}\ndelete: memberUid\nmemberUid: ${LOGIN}\n"
		done
		for POSIXGROUP in ${ADDTOGROUPS}; do
			append "dn: cn=${POSIXGROUP},${GROUPBASE}\nadd: memberUid\nmemberUid: ${LOGIN}\n"
		done
	fi
	runmodify
	if [ "${CREATEHOMEDIR}" = "yes" -a ! -d "${HOMEDIRECTORY}" ]; then
		mkdir ${HOMEDIRECTORY}
		cp -a ${SKEL}/{*,.[^.]*} ${HOMEDIRECTORY} > /dev/null 2>&1
		chmod "${HOMEPERM}" "${HOMEDIRECTORY}"
		chown -R "${UIDNUMBER}":"${GIDNUMBER}" "${HOMEDIRECTORY}"
	fi
}

usermod () {
	[ -z "${modulename}" ] && modulename="usermod"
	if [ "${#}" -le 1 ]; then
		echo "${modulename}: No flags given"
		exit 2
	fi
	while getopts "u:og:G:h:d:s:c:l:mf:e:p:LU" OPTION; do
		case "${OPTION}" in
			u) UIDNUMBER="${OPTARG}";;
			o) DUPLICATES="yes";;
			g) GID="${OPTARG}";;
			G) OTHERGROUPS="${OPTARG}";;
			h) HOSTLIST="${OPTARG}";;
			d) HOMEDIRECTORY="${OPTARG}";;
			s) LOGINSHELL="${OPTARG}";;
			c) COMMENT="${OPTARG}";;
			l) NEWLOGIN="${OPTARG}";;
			m) MOVEHOMEDIR="yes";;
			f) SHADOWINACTIVE="${OPTARG}";;
			e) SHADOWEXPIRE="${OPTARG}";;
			p) if [ -n "${LOCKED}" ]; then print_usage; exit 2; fi; USERPASSWORD="${2}";;
			L) if [ -n "${LOCKED}" -o -n "${USERPASSWORD}" ]; then print_usage; exit 2; fi; LOCKED="yes";;
			U) if [ -n "${LOCKED}" -o -n "${USERPASSWORD}" ]; then print_usage; exit 2; fi; LOCKED="no";;
			*) exit 1;;
		esac
	done
	shift $((${OPTIND} - 1))
	if [ "${#}" -ne 1 ]; then
		print_usage
		exit 2
	else
		LOGIN="${1}"
	fi
	search_user "uid" "${LOGIN}"
	if [ "$?" -ne 0 ]; then
		echo "${modulename}: User \"${LOGIN}\" does not exist"
		exit 6
	fi
	if [ -n "${UIDNUMBER}" ]; then
		echo "${UIDNUMBER}" | grep -qs "^[[:digit:]]*$"
		if [ "$?" -ne 0 ]; then
			echo "${modulename}: Invalid numeric argument \"${UIDNUMBER}\""
			exit 3
		fi
		search_user "uidNumber" "${UIDNUMBER}"
		if [ "$?" -eq 0 -a "${DUPLICATES}" != "yes" ]; then
			echo "${modulename}: uid ${UIDNUMBER} is not unique"
			exit 4
		fi
	fi
	if [ -n "${GID}" ]; then
		echo "${GID}" | grep -qs "^[[:digit:]]*$"
		if [ "$?" -eq 0 ]; then
			GIDNUMBER="${GID}"
		else
			GIDNUMBER="$(ldap_search_getattr "${GROUPBASE}" "cn=${GID}" gidNumber)"
			if [ -z "${GIDNUMBER}" ]; then
				echo "${modulename}: Unknown group \"${GID}\""
				exit 6
			fi
		fi
		search_group "gidNumber" "${GIDNUMBER}"
		if [ "$?" -ne 0 ]; then
			echo "${modulename}: Warning! Group ${GIDNUMBER} not found. Modifying user anyway."
		fi
	fi
	if [ -n "${OTHERGROUPS}" ]; then
		OTHERGROUPS="${OTHERGROUPS//,/ }"
		for POSIXGROUP in ${OTHERGROUPS}; do
			echo "${POSIXGROUP}" | grep -qs "^[[:digit:]]*$"
			if [ "$?" -eq 0 ]; then
				search_group "gidNumber" "${POSIXGROUP}"
				if [ "$?" -ne 0 ]; then
					echo "${modulename}: Unknown other group number \"${POSIXGROUP}\""
					exit 6
				fi
				POSIXGROUP="$(ldap_search_getattr "${GROUPBASE}" "gidNumber=${POSIXGROUP}" cn)"
				ADDTOGROUPS="${ADDTOGROUPS} ${POSIXGROUP}"
			else
				search_group "cn" "${POSIXGROUP}"
				if [ "$?" -ne 0 ]; then
					echo "${modulename}: Unknown other group \"${POSIXGROUP}\""
					exit 6
				fi
				ADDTOGROUPS="${ADDTOGROUPS} ${POSIXGROUP}"
			fi
		done
	fi
	if [ -n "${HOSTLIST}" ]; then
		HOSTLIST="${HOSTLIST//,/ }"
		for HOST in ${HOSTLIST}; do
			HOSTS="${HOSTS}host: ${HOST}\n"
		done
		HOSTS="$(echo -e "${HOSTS}")"
	fi
	if [ -n "${HOMEDIRECTORY}" ]; then
		echo "${HOMEDIRECTORY}" | grep -qs "^/"
		if [ "$?" -ne 0 ]; then
			echo "${modulename}: Invalid home directory \"${HOMEDIRECTORY}\""
			exit 3
		fi
	fi
	if [ -n "${LOGINSHELL}" ]; then
		echo "${LOGINSHELL}" | grep -qs "^/"
		if [ "$?" -ne 0 ]; then
			echo "${modulename}: Invalid shell \"${LOGINSHELL}\""
			exit 3
		fi
	fi
	if [ -n "${NEWLOGIN}" ]; then
		echo "${NEWLOGIN}" | grep -qs "^[[:alnum:]]*$"
		if [ "$?" -ne 0 ]; then
			echo "${modulename}: Invalid user name \"${NEWLOGIN}\""
			exit 3
		else
			search_user "uid" "${NEWLOGIN}"
			if [ "$?" -eq 0 ]; then
				echo "${modulename}: User \"${NEWLOGIN}\" exists"
				exit 9
			fi
		fi
		if [ -z "${ADDTOGROUPS}" ]; then
			#ADDTOGROUPS="$(${LDAPSEARCH} -b "${GROUPBASE}" "memberUid=${LOGIN}" | grep "^cn:" | sed "s/^cn: //")"
			ADDTOGROUPS="$(ldap_search_getattr "${GROUPBASE}" "memberUid=${LOGIN}" cn)"
		fi
	fi
	if [ -n "${HOMEDIRECTORY}" -a "${MOVEHOMEDIR}" = "yes" ]; then
		if [ "$(whoami)" != "root" ]; then
			echo "${modulename}: Only root may move home directories"
			exit 12
		fi
		PARENTDIR="$(dirname "${HOMEDIRECTORY}")"
		if [ ! -w "${PARENTDIR}" ]; then
			echo "${modulename}: Cannot create directory \"${HOMEDIRECTORY}\""
			exit 12
		fi
		OLDHOMEDIRECTORY="$(ldap_search_getattr "${USERBASE}" "uid=${LOGIN}" homeDirectory)"
	fi
	if [ -n "${SHADOWINACTIVE}" ]; then
		if [ "${SHADOWINACTIVE}" != "-1" ]; then
			echo "${SHADOWINACTIVE}" | grep -qs "^[[:digit:]]*$"
			if [ "$?" -ne 0 ]; then
				echo "${modulename}: Invalid numeric argument \"${SHADOWINACTIVE}\""
				exit 3
			fi
		fi
	fi
	if [ -n "${SHADOWEXPIRE}" ]; then
		if [ "${SHADOWEXPIRE}" != "-1" ]; then
			echo "${SHADOWEXPIRE}" | grep -qs "^[[:digit:]]\{4\}-[[:digit:]]\{2\}-[[:digit:]]\{2\}$"
			if [ "$?" -ne 0 ]; then
				echo "${modulename}: Invalid date \"${SHADOWEXPIRE}\""
				exit 3
			else
				let SHADOWEXPIRE="$(date -d "${SHADOWEXPIRE}" +%s) / 86400"
			fi
		fi
	fi
	if [ -n "${LOCKED}" ]; then
		OLDPASSWORD="$(ldap_search_getattr "${USERBASE}" "uid=${LOGIN}" userPassword)"
		if [ "${LOCKED}" = "yes" ]; then
			USERPASSWORD="!${OLDPASSWORD}"
		elif [ "${LOCKED}" = "no" ]; then
			USERPASSWORD="$(echo "${OLDPASSWORD}" | sed -re "s/^!//")"
		fi
	fi
	COMMAND_DN="dn: uid=${LOGIN},${USERBASE}\n"
	append "${COMMAND_DN}"
	[ -n "${UIDNUMBER}" ] && append_attrib "uidNumber" "${UIDNUMBER}\n-\n"
	[ -n "${GIDNUMBER}" ] && append_attrib "gidNumber" "${GIDNUMBER}\n-\n"
	[ -n "${HOSTS}" ] && append_attrib "replace: host\n${HOSTS}\n-\n"
	[ -n "${HOMEDIRECTORY}" ] && append_attrib "homeDirectory" "${HOMEDIRECTORY}\n-\n"
	[ -n "${LOGINSHELL}" ] && append_attrib "loginShell" "${LOGINSHELL}\n-\n"
	[ -n "${COMMENT}" ] && FULLNAME=${COMMENT//,*}
	[ -n "${COMMENT}" ] && append_attrib "replace: cn gecos\ncn: ${FULLNAME}\ncn: ${COMMENT}\n-\n"
	[ -n "${SHADOWINACTIVE}" ] && append_attrib "shadowInactive" "${SHADOWINACTIVE}\n-\n"
	[ -n "${SHADOWEXPIRE}" ] && append_attrib "shadowExpire" "${SHADOWEXPIRE}\n-\n"
	[ -n "${USERPASSWORD}" ] && append_attrib "userPassword" "${USERPASSWORD}\n-\n"
	[ "${COMMAND}" = "${COMMAND_DN}" ] && unset COMMAND
	[ -n "${NEWLOGIN}" ] && append "dn: uid=${LOGIN},${USERBASE}\nchangetype: modrdn\nnewrdn: uid=${NEWLOGIN}\n"
	if [ -n "${ADDTOGROUPS}" ]; then
		DELETEFROMGROUPS="$(ldap_search_getattr "${GROUPBASE}" "memberUid=${LOGIN}" cn)"
		for POSIXGROUP in ${DELETEFROMGROUPS}; do
			append "dn: cn=${POSIXGROUP},${GROUPBASE}\ndelete: memberUid\nmemberUid: ${LOGIN}\n"
		done
		[ -n "${NEWLOGIN}" ] && LOGIN="${NEWLOGIN}"
		for POSIXGROUP in ${ADDTOGROUPS}; do
			append "dn: cn=${POSIXGROUP},${GROUPBASE}\nadd: memberUid\nmemberUid: ${LOGIN}\n"
		done
	fi
	runmodify
	if [ "${MOVEHOMEDIR}" = "yes" ]; then
		mv ${OLDHOMEDIRECTORY} ${HOMEDIRECTORY} > /dev/null 2>&1
		chmod "${HOMEPERM}" "${HOMEDIRECTORY}"
		chown -R "${UIDNUMBER}":"${GIDNUMBER}" "${HOMEDIRECTORY}"
	fi
}

userdel () {
	[ -z "${modulename}" ] && modulename="userdel"
	while getopts "r" OPTION; do
		case "${OPTION}" in
			r) REMOVEHOMEDIR="yes";;
			*) exit 1;;
		esac
	done
	shift $((${OPTIND} - 1))
	if [ "${#}" -ne 1 ]; then
		print_usage
		exit 2
	else
		LOGIN="${1}"
	fi
	search_user "uid" "${LOGIN}"
	if [ "$?" -ne 0 ]; then
		echo "${modulename}: User \"${LOGIN}\" does not exist"
		exit 6
	fi
	if [ "${REMOVEHOMEDIR}" = "yes" ]; then
		if [ "$(whoami)" != "root" ]; then
			echo "${modulename}: Only root may remove home directories"
			exit 12
		fi
		HOMEDIRECTORY="$(ldap_search_getattr "${USERBASE}" "uid=${LOGIN}" homeDirectory)"
		UIDNUMBER="$(ldap_search_getattr "${USERBASE}" "uid=${LOGIN}" uidNumber)"
	fi
	append "dn: uid=${LOGIN},${USERBASE}\nchangetype: delete\n"
	DELETEFROMGROUPS="$(ldap_search_getattr "${GROUPBASE}" "memberUid=${LOGIN}" cn)"
	for POSIXGROUP in ${DELETEFROMGROUPS}; do
		append "dn: cn=${POSIXGROUP},${GROUPBASE}\ndelete: memberUid\nmemberUid: ${LOGIN}\n"
	done
	runmodify
	if [ "${REMOVEHOMEDIR}" = "yes" -a -d "${HOMEDIRECTORY}" ]; then
		OWNER_UIDNUMBER="$(stat "${HOMEDIRECTORY}" |
			grep "Uid:" |
			sed "s/^.*Uid:.*(\(.*\)\/.*Gid:.*$/\1/" | tr -d " ")"
		if [ "${UIDNUMBER}" -eq "${OWNER_UIDNUMBER}" ]; then
			rm -rf "${HOMEDIRECTORY}"
		else
			echo "${modulename}: ${HOMEDIRECTORY} not owned by user \"${LOGIN}\", not removing"
			exit 12
		fi
	fi
}

groupadd () {
	[ -z "${modulename}" ] && modulename="groupadd"
	while getopts "g:o" OPTION; do
		case "${OPTION}" in
			g) GIDNUMBER="${OPTARG}";;
			o) DUPLICATES="yes";;
			*) exit 1;;
		esac
	done
	shift $((${OPTIND} - 1))
	if [ "${#}" -ne 1 ]; then
		print_usage
		exit 2
	else
		CN="${1}"
	fi
	echo "${CN}" | grep -qs "^[[:alnum:]]*$"
	if [ "$?" -ne 0 ]; then
		echo "${modulename}: \"${CN}\" is not a valid group name"
		exit 3
	else
		search_group "cn" "${CN}"
		if [ "$?" -eq 0 ]; then
			echo "${modulename}: Group \"${CN}\" exists"
			exit 9
		fi
	fi
	if [ -n "${GIDNUMBER}" ]; then
		echo "${GIDNUMBER}" | grep -qs "^[[:digit:]]*$"
		if [ "$?" -ne 0 ]; then
			echo "${modulename}: Invalid numeric argument \"${GIDNUMBER}\""
			exit 2
		fi
		search_group "gidNumber" "${GIDNUMBER}"
		if [ "$?" -eq 0 -a "${DUPLICATES}" != "yes" ]; then
			echo "${modulename}: gid ${GIDNUMBER} is not unique"
			exit 4
		fi
	else
		GIDNUMBER="${GIDNUMBER}MIN"
		while [ "${GIDNUMBER}" -le "${GIDNUMBER}MAX" ]; do
			search_group "gidNumber" "${GIDNUMBER}"
			[ "$?" -ne 0 ] && break
			let GIDNUMBER="${GIDNUMBER} + 1"
		done
	fi
	# setup commands
	append "dn: cn=${CN},${GROUPBASE}"
	append "changetype: add"
	append "objectClass: top"
	append "objectClass: posixGroup"
	append "cn: ${CN}"
	append "gidNumber: ${GIDNUMBER}"
	append "\n\n"
	runmodify
}

groupmod () {
	[ -z "${modulename}" ] && modulename="groupmod"
	if [ "${#}" -le 1 ]; then
		echo "${modulename}: No flags given"
		exit 2
	fi
	while getopts "g:on:" OPTION; do
		case "${OPTION}" in
			g) GIDNUMBER="${OPTARG}";;
			o) DUPLICATES="yes";;
			n) NEWCN="${OPTARG}";;
			*) exit 1;;
		esac
	done
	shift $((${OPTIND} - 1))
	if [ "${#}" -ne 1 ]; then
		print_usage
		exit 2
	else
		CN="${1}"
	fi
	search_group "cn" "${CN}"
	if [ "$?" -ne 0 ]; then
		echo "${modulename}: Group \"${CN}\" does not exist"
		exit 6
	fi
	if [ -n "${GIDNUMBER}" ]; then
		echo "${GIDNUMBER}" | grep -qs "^[[:digit:]]*$"
		if [ "$?" -ne 0 ]; then
			echo "${modulename}: Invalid numeric argument \"${GIDNUMBER}\""
			exit 2
		fi
		search_group "gidNumber" "${GIDNUMBER}"
		if [ "$?" -eq 0 -a "${DUPLICATES}" != "yes" ]; then
			echo "${modulename}: gid ${GIDNUMBER} is not unique"
			exit 4
		fi
	fi
	if [ -n "${NEWCN}" ]; then
		echo "${NEWCN}" | grep -qs "^[[:alnum:]]*$"
		if [ "$?" -ne 0 ]; then
			echo "${modulename}: \"${NEWCN}\" is not a valid group name"
			exit 3
		else
			search_group "cn" "${NEWCN}"
			if [ "$?" -eq 0 ]; then
				echo "${modulename}: \"${NEWCN}\" is not a unique name"
				exit 9
			fi
		fi
	fi
	[ -n "${GIDNUMBER}" ] && append "dn: cn=${CN},${GROUPBASE}\nreplace: gidNumber\ngidNumber: ${GIDNUMBER}\n"
	[ -n "${NEWCN}" ] && append "dn: cn=${CN},${GROUPBASE}\nchangetype: modrdn\nnewrdn: cn=${NEWCN}"
	runmodify
}

groupdel () {
	[ -z "${modulename}" ] && modulename="groupdel"
	if [ "${#}" -ne 1 ]; then
		print_usage
		exit 2
	else
		CN="${1}"
	fi
	search_group "cn" "${CN}"
	if [ "$?" -ne 0 ]; then
		echo "${modulename}: Group \"${CN}\" does not exist"
		exit 6
	fi
	rundelete "cn=${CN},${GROUPBASE}" 
}

grabinteractiveinput() {
	msg="${1}"
	setting="${2}"
	echo -en "${msg}"
	read userinput
	userinput="`echo "${userinput}" | sed -re 's/^[[:space:]]*//g;s/[[:space:]]*$//g;'`"
	eval ${setting}="${userinput}"
}

chsh() {
	[ -z "${modulename}" ] && modulename="chsh"
	while getopts "s:" OPTION; do
		case "${OPTION}" in
			s) LOGINSHELL="${OPTARG}";;
		esac
	done
	shift $((${OPTIND} - 1))
	if [ "${#}" -ne 1 ]; then
		print_usage
		exit 2
	else
		LOGIN="${1}"
	fi
	# TODO - FIXME!
	OLDLOGINSHELL="getoldshell"
	if [ -z "${LOGINSHELL}" ]; then
		msg="Changing the login shell for ${LOGIN}\nEnter the new value, or press return for the default\n\tLogin Shell [${OLDLOGINSHELL}]: "
		grabinteractiveinput "${msg}" LOGINSHELL
		[ -z "${LOGINSHELL}" ] && LOGINSHELL="${OLDLOGINSHELL}"
	fi

	# recursive behaviour is nice...
	# But we only do the call if they are changing the shell
	[ "${OLDLOGINSHELL}" != "${LOGINSHELL}" ] && usermod -s "${LOGINSHELL}" "${LOGIN}"
}

chfn() {
	[ -z "${modulename}" ] && modulename="chfn"
	while getopts "f:h:o:r:w:" OPTION; do
		case "${OPTION}" in
			f) FULLNAME="${OPTARG}";;
			h) HOMEPHONE="${OPTARG}";;
			o) OTHER="${OPTARG}";;
			r) ROOMNUMBER="${OPTARG}";;
			w) WORKPHONE="${OPTARG}";;
		esac
	done
	shift $((${OPTIND} - 1))
	if [ "${#}" -ne 1 ]; then
		print_usage
		exit 2
	else
		LOGIN="${1}"
	fi

	[ -n "${HOMEPH}" ] && append ""
	#FULLNAME="$(echo ${COMMENT} | cut -d, -f1)"
	#ROOMNUMBER="$(echo ${COMMENT} | cut -d, -f2)"
	#WORKPHONE="$(echo ${COMMENT} | cut -d, -f3)"
	#HOMEPHONE="$(echo ${COMMENT} | cut -d, -f4)"
	
	if [ -n "${FULLNAME}" ]; then
		FIRSTNAME="${FULLNAME// *}"
		SURNAME="${FULLNAME##* }"
		CN="${FIRSTNAME}"

	fi
	[ -n "${SURNAME}" ] && append "replace: sn\nsn: ${SURNAME}"
	[ -n "${FIRSTNAME}" ] && append "givenName: ${FIRSTNAME}"
	[ -n "${FULLNAME}" ] && append "displayName: ${FULLNAME}"
	[ -n "${ROOMNUMBER}" ] && append "roomNumber: ${ROOMNUMBER}"
	[ -n "${HOMEPHONE}" ] && append "homePhone: ${HOMEPHONE}"
	[ -n "${WORKPHONE}" ] && append "telephoneNumber: ${WORKPHONE}"
	append "gecos: ${COMMENT}"
	append "\n\n"

	echo "Not done yet!"
	exit 99
}

chage() {
	# TODO
	echo "Not done yet! "
	exit 99
}

gpasswd() {
	# TODO
	echo "Not done yet!"
	exit 99
}

case "${1}" in
	useradd|usermod|userdel|groupadd|groupmod|groupdel|chsh|chfn|chage|gpasswd)
		ACTION="${1}"
		shift 1
		${ACTION} "$@"
		;;
		# host - http://publib16.boulder.ibm.com/pseries/en_US/files/aixfiles/hosts.htm#seg3b0sara
		# network - http://publib16.boulder.ibm.com/pseries/en_US/files/aixfiles/networks_NFS.htm#idx232
		# protocol - http://publib16.boulder.ibm.com/pseries/en_US/files/aixfiles/protocols.htm#idx546
		# service - http://publib16.boulder.ibm.com/pseries/en_US/files/aixfiles/services.htm#idx574
		# rpc - http://publib16.boulder.ibm.com/pseries/en_US/files/aixfiles/rpc.htm#idx286
		# ether - http://publib16.boulder.ibm.com/pseries/en_US/files/aixfiles/ethers.htm#idx111
		# netmask - http://publib16.boulder.ibm.com/pseries/en_US/files/aixfiles/netmasks.htm#idx226
		# netgroup - http://publib16.boulder.ibm.com/pseries/en_US/files/aixfiles/netgroup.htm#xqr310mart
		# bootparam - http://publib16.boulder.ibm.com/pseries/en_US/files/aixfiles/bootparams.htm#idx32
		# automount
		# aliases - http://publib16.boulder.ibm.com/pseries/en_US/files/aixfiles/aliases.htm#idx12
	
	--version)
		print_version
		exit 0
		;;
	--help)
		print_usage
		exit 0
		;;
	*)
		print_usage
		exit 1
		;;
esac

exit 0

# vim: ts=4 sts=4 noexpandtab sw=4 ft=sh:
